"""Module for plotting segmentation results from decision tree models.

This module provides functions for visualizing the segmentation results
generated by decision tree models, helping to interpret the model's decisions.
"""

from dataclasses import dataclass

import pandas as pd
import plotly.graph_objects as go
from plotly.graph_objects import Figure


def plot_single_segmentation_impl(df: pd.DataFrame, lower_is_better: bool = True) -> Figure:
    """Implement the single segmentation plot as a bar chart.

    Parameters
    ----------
    df : pd.DataFrame
        A DataFrame containing the groups defined by the decision tree model.
        columns:
        - `segment_id`: The ID of the segment, for grouping.
        - `segment_name`: (str) the range or category of the feature.
        - `score`: (float) The calculated error metric for the segment.
    lower_is_better : bool, default=True
        Whether lower values of the metric indicate better performance.
        Affects the color scale in visualizations (green for better, red for worse).

    Returns
    -------
    Figure
        A bar chart showing each segment with its corresponding avg score, x-axis represents
        the feature segments (segment_name), and y-axis shows the score.

    """
    # Sort by segment_id to ensure consistent ordering
    df_sorted = df.sort_values(by="segment_id")

    # Choose colorscale based on lower_is_better
    if lower_is_better:
        colorscale = [[0, "green"], [0.5, "yellow"], [1, "red"]]  # Low (green) to high (red)
    else:
        colorscale = [[0, "red"], [0.5, "yellow"], [1, "green"]]  # Low (red) to high (green)

    # Create a bar chart
    fig = go.Figure(
        data=[
            go.Bar(
                x=df_sorted["segment_name"].astype(str),
                y=df_sorted["score"],
                marker=dict(
                    color=df_sorted["score"],
                    colorscale=colorscale,
                    colorbar=dict(title="Score"),
                ),
                text=df_sorted["score"].round(3),
                textposition="auto",
            )
        ]
    )

    # Customize layout
    fig.update_layout(
        title="Segmentation Analysis by Feature",
        xaxis_title="Feature Segments",
        yaxis_title="Error Score",
        template="plotly_white",
        coloraxis_showscale=True,
    )

    return fig


def plot_single_segmentation(df: pd.DataFrame, lower_is_better: bool = True) -> Figure:
    """Plot the single segmentation of a given DataFrame as a bar chart.

    Parameters
    ----------
    df : pd.DataFrame
        A DataFrame containing the groups defined by the decision tree model.
        columns:
        - `segment_id`: The ID of the segment, for grouping.
        - `segment_name`: (str) the range or category of the feature.
        - `score`: (float) The calculated error metric for the segment.
    lower_is_better : bool, default=True
        Whether lower values of the metric indicate better performance.
        Affects the color scale in visualizations (green for better, red for worse).

    Returns
    -------
    Figure
        A bar chart showing each segment with its corresponding avg score, x-axis represents
        the feature segments (segment_name), and y-axis shows the score.

    """
    return plot_single_segmentation_impl(df, lower_is_better)


@dataclass
class DoubleSegmPlotting:
    """Class for double segmentation plotting.

    This class implements the interface for plotting double segmentations.
    It includes the DataFrames to be plotted and the kind of plot to be created.

    Parameters
    ----------
    df : pd.DataFrame
        A DataFrame containing the groups defined by the decision tree model.
        columns:
        - `segment_id`: The ID of the segment, for grouping.
        - `feature_1`: (str) the range or category of the first feature.
        - `feature_2`: (str) the range or category of the second feature.
        - `score`: (float) The calculated error metric for the segment.
    metric_name : str, default="score"
        The name of the metric column in the DataFrame.
    lower_is_better : bool, default=True
        Whether lower values of the metric indicate better performance.
        Affects the color scale in visualizations (green for better, red for worse).

    """

    df: pd.DataFrame
    metric_name: str = "score"
    lower_is_better: bool = True

    def get_heatmap_df(self) -> pd.DataFrame:
        """Get the DataFrame for the heatmap from the double segmentation df.

        Returns
        -------
        pd.DataFrame
            A DataFrame containing the groups defined by the decision tree model.
            columns: feature_1 ranges or categories
            index: feature_2 ranges or categories
            content: The calculated error metric for the segment.

        """
        # Pivot the dataframe to create a heatmap-ready format
        pivot_df = self.df.pivot(index="feature_2", columns="feature_1", values=self.metric_name)

        return pivot_df

    def plot_heatmap(self) -> Figure:
        """Plot the double segmentation of a given DataFrame as a heatmap.

        Returns
        -------
        Figure
            A heatmap showing each segment with its corresponding avg score,
            from get_heatmap_df() method. Colors are determined by the lower_is_better parameter:
            - If lower_is_better=True: Lower values are green (better), higher values are red (worse)
            - If lower_is_better=False: Higher values are green (better), lower values are red (worse)

        """
        heatmap_df = self.get_heatmap_df()

        # Choose colorscale based on lower_is_better
        if self.lower_is_better:
            colorscale = [[0, "green"], [0.5, "yellow"], [1, "red"]]  # Low (green) to high (red)
        else:
            colorscale = [[0, "red"], [0.5, "yellow"], [1, "green"]]  # Low (red) to high (green)

        # Create heatmap
        fig = go.Figure(
            data=go.Heatmap(
                z=heatmap_df.values,
                x=heatmap_df.columns,
                y=heatmap_df.index,
                colorscale=colorscale,
                text=heatmap_df.round(3).values,
                texttemplate="%{text}",
                colorbar=dict(title=self.metric_name),
            )
        )

        # Customize layout
        fig.update_layout(
            title="Double Segmentation Heatmap",
            xaxis_title="Feature 1",
            yaxis_title="Feature 2",
            template="plotly_white",
        )

        return fig
